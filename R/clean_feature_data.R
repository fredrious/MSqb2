#' Clean Feature-level Data
#'
#' This function cleans and filters feature-level (psm-level) data based on various criteria such as contaminant removal, isolation interference, and intensity thresholds. It also handles multiple PSM measurements per feature, removes single-shot proteins, and calculates basic statistics before and after filtering.
#'
#' @param dat A `data.table` containing the feature-level data.
#' @param metadata A `data.table` containing metadata associated with the MS data.
#' @param filter.by.quaninfo Character. Specifies the method for filtering MS data generated by PD based on quantitative information. Options are `"auto"`, `"none"`, or a specific label. Default is `"auto"`.
#' @param isolation.interference.cutoff Numeric or NULL. The threshold for filtering based on isolation interference. Features with interference above this value are removed. Default is `75`.
#' @param collapse_psm_method Character. Method for handling multiple PSM measurements per feature. Default is `"TagPSM"`.
#' @param filter.singleshot.proteins Character. Method for filtering single-shot proteins. Options are `"BYPEPTIDE"` or `"BYFEATURE"`. Default is `"BYPEPTIDE"`.
#' @param min.intensity Numeric. Minimum intensity threshold below which intensity values are considered missing. Default is `0.01`.
#'
#' @return A list containing the cleaned `msDT`, a `BasicStats` table with summary statistics, and `Isol.Interference` data.
#'
#' @details The function performs the following steps:
#' \itemize{
#'   \item Removes rows where protein data is missing or marked as a contaminant.
#'   \item Filters out single-shot proteins both before and after peptide filtering.
#'   \item Removes features with intensities below the specified minimum threshold.
#'   \item Filters features based on isolation interference and quantitative information.
#'   \item Consolidates multiple PSM measurements per feature.
#'   \item Outputs basic statistics before and after the cleaning process.
#' }
#'
#' @examples
#' \dontrun{
#'   clean_data <- clean_feature_data(dat = my_data, metadata = my_metadata)
#' }
#'
#' @importFrom magrittr %>% %<>%
#' @export
clean_feature_data <- function(dat,
                                metadata,
                                filter.by.quaninfo = "auto",
                                isolation.interference.cutoff = 75,
                                collapse_psm_method = "TagPSM",
                                filter.singleshot.proteins = "BYPEPTIDE",
                                min.intensity = 0.01) {



  ## remove rows where protein is NA, SP, empty ...
  ##!!! depricated 27.2.2032 -> use "marked as" instead -> remove contaminants
  # dat %<>% .rmBadProt(.)


  ## Basic statistics "Before Filtering"
  np0 <- uniqueN(dat$Protein)
  dtcnt <- c(
    "Proteins (before Filtering)" = uniqueN(dat$Protein),
    "Peptides (before Filtering)" = uniqueN(dat$Peptide)
  )



  ## remove rows in which no accession code is avalable (missing)
  dat <- dat[!is.na(Protein)]


  ## remove contaminants
  if ("Contaminant" %in% names(dat)) {
    dat %<>% .[!(Contaminant)] %>%
      .[, Contaminant := NULL] %>%
      .[!tolower(Protein) %like% "cont"]
  }
  if ("MarkedAs" %in% names(dat)) {
    dat %<>% .[!tolower(MarkedAs) %like% "contaminant"] %>%
      .[, MarkedAs := NULL] %>%
      .[!tolower(Protein) %like% "cont"]
  }
  dtcnt["Proteins marked as contaminant"] <- np0 - uniqueN(dat$Protein)


  ## check single-shot proteins (before Peptide Filtering)
  dat %<>% .rmSnglProt(., filter.singleshot.proteins, when = "before", dtcnt)
  dtcnt <- c(dtcnt, dat[[2]])
  dat <- dat[[1]]


  ## remove zero and negative intensities
  dat %<>% .[Intensity <= min.intensity, Intensity := 1] %>% unique(.)


  cat("*** Peptide Filtering ***")

  ## exclude peptides based on info provided by quan.info
  if (filter.by.quaninfo != "none") {
    if ("Quaninfo" %in% names(dat)) {
      if (filter.by.quaninfo == "auto") {
        filter.by.quaninfo <- unique(dat[!is.na(Quaninfo), Quaninfo]) %>%
          toupper(.) %>%
          setdiff(., "UNIQUE")
      }
      badFeature <- unique(dat[toupper(Quaninfo) %in% filter.by.quaninfo, Feature])
      dtcnt["Miss.Quant/non-unique/No-Label Features"] = length(badFeature)

      cat("\n--- ", length(badFeature), " Features (~", round(length(badFeature) / uniqueN(dat$Feature), 2) * 100,
        "% of all Features) with the following labels will be removed.\n",
        paste(unique(filter.by.quaninfo), collapse = ", "),
        sep = ""
      )

      dat <- dat[!Feature %in% badFeature, ]
      dat$Quaninfo <- NULL
    }
  } else {
    dtcnt["Miss.Quant/non-unique/No-Label Features"] = "NA"
    badFeature <- c()
  }




  ## remove peptides by Isolation interference
  if (!is.null(isolation.interference.cutoff)) {
    if ("Interference" %in% names(dat)) {
      Isol.Interference <- list(
        "cutoff" = isolation.interference.cutoff,
        "Interference" = dat$Interference
      )
      n1 <- uniqueN(dat$Feature)

      cat("\n--- ", n1, " Features with Isolation Interference greater than ",
        isolation.interference.cutoff, "% will be removed!\n",
        sep = ""
      )


      dat <- dat[Interference < isolation.interference.cutoff, ]
      n2 <- uniqueN(dat$Feature)

      dtcnt[paste0(
        "Removed Feature due to high isolation interference (>",
        isolation.interference.cutoff, "%)"
      )] = n1 - n2

      dat$Interference <- NULL
    } else {
      message("!!! Unable to find Isolation Interference column in the data. Filter can not be applied!")
    }
  } else {
    dtcnt[paste0(
      "Removed redundant Feature due to high isolation interference (>",
      isolation.interference.cutoff, "%)"
    )] = "NA"
  }



  ## Dealing with multiple PSM measurements per feature and run.
  # dat %<>% collapse_psm(., method = collapse_psm_method, by = c(row.p, "Channel"))
  dat %<>% collapse_psm(.,
    method = collapse_psm_method, by =
      intersect(
        c("Protein", "Peptide", "Charge", "Filename", "Pool", "Channel"),
        names(dat)
      )
  )



  ## Filter peptides/features with complete missingness
  if (MSmethod == "TMT") {
    All_NA_Feat <- dat[, .(sm = sum(is.na(Intensity)), cn = .N), by = Feature] %>%
      .[sm == cn, Feature]
    dat %<>% .[!Feature %in% All_NA_Feat]

    cat("--- ", uniqueN(All_NA_Feat), " Features with total missingness will be removed!\n", sep = "")
  }



  ## Removing shared peptides between proteins (each peptide should belong only to 1 protein group)
    unqPpt <- dat[, .(n = uniqueN(Protein)), by = Peptide]

    if (nrow(unqPpt[n != 1]) != 0) {
      dtcnt["MissQuant/non-unique Peptides"] = nrow(unqPpt[n != 1]) + length(badFeature)
    }
    cat("--- ", nrow(unqPpt[n != 1]),
      " Peptides which are shared between multiple proteins (non-unique peptides) will be removed! ---",
      sep = ""
    )
    dat <- dat[Peptide %in% unqPpt[n == 1, Peptide], ]


  ## check single-shot proteins (after Peptide Filtering)
  dat %<>% .rmSnglProt(., filter.singleshot.proteins, when = "after", dtcnt)
  dtcnt <- c(dtcnt, dat[[2]])
  dat <- dat[[1]]



  ## continue with basic stats
  if (MSmethod %in% c("TMT", "LFQ")) {
    dtcnt["Features (after peptide Filtering)"] <- uniqueN(dat$Feature)
    # dtcnt["Removed proteins due to peptide Filtering"] <-
    #   dtcnt["Proteins (before Filtering)"] -
    #   dtcnt["Single-shot Proteins (after peptide Filtering)"]
    dtcnt["Proteins (after Filtering)"] <- uniqueN(dat$Protein)
    BasicStats <- as.data.table(dtcnt, keep.rownames = TRUE)
    colnames(BasicStats) <- c("Parameter", "Count")
  }



  ## subset columns to those needed!
  if (ms.software == "MQ") setnames(dat, "Run", "Filename")
  output.var <- c(
    "Protein", "Peptide", "Feature", "Pool", "Fraction", "Channel",
    "Condition", "TechRep", "Intensity", "Filename", "Description"
  ) %>%
    c(., names(metadata)) %>%
    unique(.)
  dat <- dat[, output.var[output.var %in% names(dat)], with = FALSE]



  list(
    "msDT" = dat,
    "BasicStats" = BasicStats,
    "Isol.Interference" = Isol.Interference
  ) %>% return(.)
}




## find and remove SP Proteins!
## depricated 27.2.2032 -> use "marked as" instead -> remove contaminants
# .rmBadProt <- function(feat.dt) {
#   ## Removing SP proteins (rows with Master.Protein.Accessions == "SP")
#   feat.dt[, Protein := gsub(" ", "", Protein, fixed = TRUE)]
#   feat.dt[, Protein := toupper(Protein)]
#   # remove only SP protein groups (Master.Protein.Accessions)
#   # from rest of protein groups (Master.Protein.Accessions), remove SP term
#   feat.dt[, Protein := gsub("SP;", "", Protein, fixed = TRUE)]
#   feat.dt[, Protein := gsub(";SP", "", Protein, fixed = TRUE)]
#   feat.dt <- feat.dt[!Protein == "SP", ]
#   feat.dt <- feat.dt[!Protein == ";", ]
#   feat.dt[
#     startsWith(Protein, ";"),
#     Protein := lapply(Protein, function(x) substr(x, 2, nchar(x)))
#   ]
#   feat.dt[
#     endsWith(Protein, ";"),
#     Protein := lapply(Protein, function(x) substr(x, 1, nchar(x) - 1))
#   ]
#   return(feat.dt)
# }



## filter single shot proteins
.rmSnglProt <- function(dt, filter.singleshot.proteins, when = "before", dtcnt) {
  if (toupper(filter.singleshot.proteins) == "BYPEPTIDE")
    bywhat <- ifelse("Peptide" %in% names(dt), "Peptide", "Peptide.annot")
  else
    bywhat <- "Feature"

  unqPrt <- dt[, .(n = uniqueN(get(bywhat))), by = Protein]
  # dtcnt[, paste0("Single-shot Proteins (", when, " peptide Filtering)") := unqPrt[, sum(n == 1)]]
  info <- c(unqPrt[, sum(n == 1)])
  names(info) = paste0("Single-shot Proteins (", when, " peptide Filtering)")

  singleshot <- unqPrt[, 100 * round(sum(n == 1) / length(n), 4)]

  cat("\n\n*** single shot Proteins", toupper(when), "peptide Filtering ***")
  cat("\n--- ", unqPrt[, sum(n == 1)], " Proteins (",
    singleshot, "% of all proteins) have only 1 ", bywhat, " in the dataset ",
    sep = ""
  )
  cat(
    "\nfilter.singleshot.proteins = ", filter.singleshot.proteins,
    "\nsingle shot Proteins will be omitted from the dataset!\n\n"
  )
  dt[Protein %in% unqPrt[n != 1, Protein], ] %>%
    list(., info) %>%
    return(.)
}
